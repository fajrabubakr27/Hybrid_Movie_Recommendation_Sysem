# -*- coding: utf-8 -*-
"""Hybrid_Movie_Recommendation_Sysem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AQip0p7GukCJ4bbExg3tn-aqXO9XHY11
"""

#!pip install streamlit

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel

# ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
movies = pd.read_csv("movies.csv")
ratings = pd.read_csv("ratings.csv")

# TF-IDF Vectorizer
tfidf = TfidfVectorizer(stop_words='english')
movies['genres'] = movies['genres'].fillna('')
tfidf_matrix = tfidf.fit_transform(movies['genres'])
cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)

# index mapping
indices = pd.Series(movies.index, index=movies['title']).drop_duplicates()

# SVD Model
rating_matrix = ratings.pivot_table(index='userId', columns='movieId', values='rating').fillna(0)

from sklearn.decomposition import TruncatedSVD
svd = TruncatedSVD(n_components=20)
svd_matrix = svd.fit_transform(rating_matrix)

predicted_ratings = np.dot(svd_matrix, svd.components_)

movie_ids = rating_matrix.columns
user_ids = rating_matrix.index

def get_content_recommendations(title, top_n=10):
    idx = indices.get(title)
    if idx is None:
        return pd.DataFrame({'Error': ['Movie not found.']})
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    movie_indices = [i[0] for i in sim_scores]
    return movies.iloc[movie_indices][['movieId', 'title']].assign(score=[round(s[1], 4) for s in sim_scores])

def get_collab_recommendations(user_id, top_n=10):
    if user_id not in user_ids:
        return pd.DataFrame({'Error': ['User ID not found.']})
    user_idx = list(user_ids).index(user_id)
    user_ratings = predicted_ratings[user_idx]
    top_indices = user_ratings.argsort()[::-1][:top_n]
    top_movie_ids = movie_ids[top_indices]
    results = movies[movies['movieId'].isin(top_movie_ids)][['movieId', 'title']].copy()
    results['predicted_rating'] = [round(user_ratings[i], 4) for i in top_indices]
    return results

def get_hybrid_recommendations(title, user_id, top_n=10):
    content_recs = get_content_recommendations(title, top_n=30)
    if 'Error' in content_recs.columns:
        return content_recs
    if user_id not in user_ids:
        return pd.DataFrame({'Error': ['User ID not found.']})

    user_idx = list(user_ids).index(user_id)
    user_ratings = predicted_ratings[user_idx]

    content_recs = content_recs.copy()
    content_recs = content_recs[content_recs['movieId'].isin(movie_ids)]
    content_recs['predicted_rating'] = content_recs['movieId'].apply(lambda x: user_ratings[list(movie_ids).index(x)])

    # weighted hybrid score (50% content + 50% collab)
    content_recs['hybrid_score'] = (content_recs['score'] + content_recs['predicted_rating']) / 2
    return content_recs.sort_values('hybrid_score', ascending=False).head(top_n)[['movieId', 'title', 'hybrid_score']]

from sklearn.metrics import mean_squared_error, mean_absolute_error
from math import sqrt

# Evaluate RMSE and MAE
actual = rating_matrix.values[rating_matrix.values.nonzero()]
predicted = predicted_ratings[rating_matrix.values.nonzero()]

rmse = sqrt(mean_squared_error(actual, predicted))
mae = mean_absolute_error(actual, predicted)


def evaluate_top_n(user_id, top_n=10, threshold=4.0):
    if user_id not in user_ids:
        return None
    
    user_idx = list(user_ids).index(user_id)
    actual_ratings = rating_matrix.iloc[user_idx]
    predicted_ratings_user = predicted_ratings[user_idx]
    
    actual_relevant = set(actual_ratings[actual_ratings >= threshold].index)
    top_indices = predicted_ratings_user.argsort()[::-1][:top_n]
    predicted_top_n = set(movie_ids[top_indices])
    
    true_positives = len(actual_relevant & predicted_top_n)
    precision = true_positives / len(predicted_top_n) if predicted_top_n else 0
    recall = true_positives / len(actual_relevant) if actual_relevant else 0
    f1 = 2 * (precision * recall) / (precision + recall) if precision + recall else 0
    
    return precision, recall, f1



# Ÿàÿßÿ¨Ÿáÿ© Streamlit
st.set_page_config(page_title="üé¨ Hybrid Movie Recommender", layout="centered")
st.title("üé¨ Hybrid Movie Recommendation System")

option = st.selectbox("Select recommendation type:",
                      ["Based on Movie Title", "Based on User ID", "Hybrid Recommendation","Evaluate System"])

if option == "Based on Movie Title":
    movie_name = st.text_input("Enter movie title:")
    if st.button("Get Recommendations"):
        if movie_name:
            st.write(f"Recommendations similar to: **{movie_name}**")
            st.dataframe(get_content_recommendations(movie_name))
        else:
            st.warning("Please enter a movie title.")

elif option == "Based on User ID":
    user_id = st.number_input("Enter user ID:", min_value=1, step=1)
    if st.button("Get Recommendations"):
        st.write(f"Recommendations for User ID: **{user_id}**")
        st.dataframe(get_collab_recommendations(user_id))

elif option == "Evaluate System":
    st.subheader("üîç Evaluation Metrics")
    
    st.write(f"**RMSE:** {rmse:.4f}")
    st.write(f"**MAE:** {mae:.4f}")
    
    sample_user_ids = [1, 2, 3]
    st.write("Top-N Recommendation Evaluation (for sample users):")
    for uid in sample_user_ids:
        metrics = evaluate_top_n(uid)
        if metrics:
            p, r, f1 = metrics
            st.write(f"User {uid} - Precision: {p:.2f}, Recall: {r:.2f}, F1-Score: {f1:.2f}")
        else:
            st.write(f"User {uid} not found.")


else:  # Hybrid
    user_id = st.number_input("Enter user ID:", min_value=1, step=1, key="hybrid_user")
    movie_name = st.text_input("Enter movie title:", key="hybrid_title")
    if st.button("Get Recommendations"):
        if movie_name:
            st.write(f"Hybrid recommendations for Movie: **{movie_name}**, User ID: **{user_id}**")
            st.dataframe(get_hybrid_recommendations(movie_name, user_id))
        else:
            st.warning("Please enter a movie title.")

